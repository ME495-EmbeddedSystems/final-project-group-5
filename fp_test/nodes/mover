#!/usr/bin/env python
"""
Uses moveit to move robot arm with collision objects and a target for pickup

SERVICES:
    + /reset (Reset) ~ moves the robot to the home position and creates/moves a RealSense Box into the scene.
                       Offers the ability to clear the waypoints server 
    + /step (Step) ~ moves the robot to a user-specified position with a gripper state (open/closed). 
                     If the motion plan succeeds, stores the waypoints in the parameter server
    + /follow (Follow) ~ has the robot move to each waypoint in the parameter server, either once or indefinitely

PARAMETERS:
    + /waypoints ~ initially saved waypoints for robot to follow which can be cleared/appended to with the step 
                   service

"""

import sys
import rospy
import moveit_commander
from geometry_msgs.msg import PoseStamped
from moveit_commander.conversions import pose_to_list, list_to_pose
from fp_test.srv import Step #, Follow, FollowResponse, Reset, ResetResponse
from std_srvs.srv import Empty, EmptyResponse
import actionlib
from franka_gripper.msg import GraspAction, GraspGoal, GraspEpsilon
from rospy.core import logdebug
from math import pi


class Mover():
    """ Moves interbotix arm with moveit planning and commands
    """
    def __init__(self):
        super(Mover, self).__init__()
        self.robot = moveit_commander.RobotCommander()
        self.scene = moveit_commander.PlanningSceneInterface()
        group_name = "panda_arm"
        gripper_name = "hand"
        self.move_group = moveit_commander.MoveGroupCommander(group_name)
        self.gripper_group = moveit_commander.MoveGroupCommander(gripper_name)
        self.planning_frame = self.move_group.get_planning_frame()
        self.waypoints = rospy.get_param("/waypoints")
        # self.reset = rospy.Service("reset", Reset, self.reset_callback)
        self.step = rospy.Service("step", Step, self.step_callback)
        self.follow = rospy.Service("follow", Empty, self.follow_callback)
        self.ee = rospy.Service("ee", Empty, self.ee_callback) 
        
        # simple action client
        self.client = actionlib.SimpleActionClient("/franka_gripper/grasp", GraspAction)

        self.add_table()
        self.add_table1()
        # self.add_airpod()     # use to add small collision object 
    
    def wait_for_state_update(self, box_name, box_is_known=False, box_is_attached=False, timeout=4):
        """ Waits until changes are reflected in object lists 

        Ensures that collision updates are made in case the python node dies before publishing.
        Integrated from Interbotix MoveIt Python Move Group Tutorials

        Args: 
            box_name (string) : name of the box being added 
            box_is_known (bool) : if box is in get_known_object_names()
            box_is_attached (bool) : if box is in get_attached_objects()
            timeout (int) : time limit

        Returns:
            False (bool) : false return if the while loop is exited without returning (a timeout)
        
        """
        start = rospy.get_time()
        seconds = rospy.get_time()

        while (seconds - start < timeout) and not rospy.is_shutdown():
            attached_objects = self.scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            is_known = box_name in self.scene.get_known_object_names()

            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            rospy.sleep(0.1)
            seconds = rospy.get_time()

        return False

    def add_table(self):
        """ Adds table to planning scene 

        Places table collision object based on the world frame

        """
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = 0.25
        table_pose.pose.position.y = -0.55
        table_pose.pose.position.z = -0.025
        table_pose.pose.orientation.w = 1.0
        table_name = "table"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(1.0, 0.62, 0.05))

    def add_table1(self):
        """ Adds table to planning scene 

        Places table collision object based on the world frame

        """
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = 0.35
        table_pose.pose.position.y = 0.1
        table_pose.pose.position.z = -0.025
        table_pose.pose.orientation.w = 1.0
        table_name = "table1"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(0.5, 0.62, 0.05))
    """
    ##############Add more collision tables around the bottom #################
    """
    
    def step_callback(self, data):
        """ Callback for the step service 

        Moves the robot based on user-input pose values

        Args:
            data (Step) : pose data from user input to use with moveit planning 

        Returns:
            error_code (Step) : MoveItErrorCodes message which signifies success or failure 

        """

        pose = data.pose
        gripper = data.gripper
        rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 1.0)
        velocity = rospy.get_param("/robot_description_planning/default_velocity_scaling_factor")
        logdebug(velocity)
        self.move_group.set_pose_target(pose)
        success_flag, trajectory_message, planning_time, error_code = self.move_group.plan()
        if not success_flag:
            return error_code

        self.move_group.execute(trajectory_message, wait=True)
        self.move_group.stop()
        self.move_group.clear_pose_targets()

        if gripper:
            self.gripper_group.set_named_target("close")
            logdebug("moving")
            # self.grip()
            self.gripper_group.go()
            self.gripper_group.stop()
            self.gripper_group.clear_pose_targets()
        else:
            self.gripper_group.set_named_target("open")
            self.gripper_group.go()
            self.gripper_group.stop()
            self.gripper_group.clear_pose_targets()
        

        # self.waypoints.append([pose_to_list(pose), gripper])
        # rospy.set_param("/waypoints", self.waypoints)
        rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 0.1)
        velocity = rospy.get_param("/robot_description_planning/default_velocity_scaling_factor")
        logdebug(velocity)
        return error_code

    def grip(self):
        # self.client.wait_for_server()
        logdebug("working")
        ep = GraspEpsilon(inner = 0.001, outer = 0.001)
        action = GraspGoal()
        action.width = 0.05
        action.epsilon = ep
        action.speed = 0.1
        action.force = 10
        self.client.send_goal(action)
        logdebug("success")
        self.client.wait_for_result(rospy.Duration(15.0))


    def ee_callback(self, event=None):
        # joints = {"panda_joint1":0, "panda_joint2":-pi/4, "panda_joint3":0, "panda_joint4":-3*pi/4, "panda_joint5":0, "panda_joint6":pi/2, "panda_joint7":3*pi/4}
        rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 1.0)
        self.move_group.remember_joint_values("panda_arm")
        joints = self.move_group.get_remembered_joint_values()
        joint = joints["panda_arm"]
        joint[-1] = 5*pi/4
        self.move_group.set_joint_value_target(joint)
        self.move_group.go()
        self.move_group.stop()
        self.move_group.clear_pose_targets()

        rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 0.1)
        return []

    def turn(self):
        joint = self.move_group.get_current_joint_values()
        # self.move_group.remember_joint_values("panda_arm")
        # joints = self.move_group.get_remembered_joint_values()
        # joint = joints["panda_arm"]
        # joint 7 values are between -166 and 166
        logdebug(joint)
        if joint[-1] > 0:
            joint[-1] -= pi
        else:
            joint[-1] += pi
        logdebug(joint)
        # joint[-1] = 5*pi/4
        # joint[-1] = 3*pi/4
        self.move_group.set_joint_value_target(joint)
        self.move_group.go()
        self.move_group.stop()
        self.move_group.clear_pose_targets()

        return []

    def follow_callback(self, event=None):
        """ Callback function for the follow service 

        Moves the robot to follow waypoints in the parameter server

        Args: 
            data (Follow) : boolean user-input for repeating the cycle or running just once

        Returns:
            FollowResponse (Follow) : empty response
        
        """
        i = 0
        # if using rpy then euleur to quaternion will give exact movement without offset
        for waypoint in self.waypoints:
            pose = list_to_pose(waypoint[0])
            gripper = waypoint[1]

            rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 1.0)
            velocity = rospy.get_param("/robot_description_planning/default_velocity_scaling_factor")
            logdebug(velocity)

            self.move_group.set_pose_target(pose)
            success_flag, trajectory_message, planning_time, error_code = self.move_group.plan()
            self.move_group.execute(trajectory_message, wait=True)
            self.move_group.stop()
            self.move_group.clear_pose_targets()

            if gripper:
                self.gripper_group.set_named_target("close")
                logdebug("moving")
                # self.grip()
                self.gripper_group.go()
                self.gripper_group.stop()
                self.gripper_group.clear_pose_targets()
            else:
                self.gripper_group.set_named_target("open")
                self.gripper_group.go()
                self.gripper_group.stop()
                self.gripper_group.clear_pose_targets()

            if i == 2:
                self.turn()
            i += 1
            rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 0.1)
            velocity = rospy.get_param("/robot_description_planning/default_velocity_scaling_factor")
            logdebug(velocity)

        return EmptyResponse()
        

def main():
    moveit_commander.roscpp_initialize(sys.argv)
    rospy.init_node("mover", anonymous=True, log_level=rospy.DEBUG)
    Mover()
    rospy.spin()

if __name__=="__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass