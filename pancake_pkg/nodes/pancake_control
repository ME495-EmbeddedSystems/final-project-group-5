#!/usr/bin/env python

"""
Flipping pancakes 

SERVICES:
    + /flip (Empty) ~ has the robot move to each waypoint and flip the pancake

PARAMETERS:
    + /waypoints ~ waypoints for the robot to follow depending on task

"""

import numpy as np
import rospy
import sys
import moveit_commander
import geometry_msgs
from geometry_msgs.msg import PoseStamped, Pose
from moveit_commander.conversions import pose_to_list, list_to_pose
from std_srvs.srv import Empty, EmptyResponse
import actionlib
from franka_gripper.msg import GraspAction, GraspGoal, GraspEpsilon
from rospy.core import logdebug
from math import pi
from tf_conversions import transformations
import tf2_ros
from nav_msgs.msg import Odometry

class ManipulatorControl:
    def __init__(self):
        super(ManipulatorControl, self).__init__()
        # initialize moveit commander
        moveit_commander.roscpp_initialize(sys.argv)
        

        # parameters

        # pubs, subs, servs, etc.

        # instantiate robot commander object
        self.robot = moveit_commander.RobotCommander()

        # instantiate scene object
        self.scene = moveit_commander.PlanningSceneInterface()

        # instantiate move groups
        self.arm_move_group = moveit_commander.MoveGroupCommander('panda_arm')
        self.gripper_move_group = moveit_commander.MoveGroupCommander('hand')
        
        self.planning_frame = self.arm_move_group.get_planning_frame()
        
        self.waypoints = rospy.get_param("/waypoints")
        self.object = rospy.get_param("/object") #assumes center of object
        self.base = rospy.get_param("/base") #assumes center of base
        self.flip = rospy.Service("flip", Empty, self.flip_callback)
        self.pour = rospy.Service("pour",Empty,self.pour_callback)

        # simple action client
        self.client = actionlib.SimpleActionClient("/franka_gripper/grasp", GraspAction)

        self.add_table()
        self.add_table1()
        #self.add_object()
        self.object = Pose()

        # object dimensions
        self.object_size = [.1, .08, .5] # this is something we could define for each object
        self.pub = rospy.Publisher('base_object', Odometry, queue_size=10)
        rospy.Subscriber('base_object', Odometry, self.callback)
        self.eef_link = self.arm_move_group.get_end_effector_link()

	
    def callback(self, data):
        """Creates the callback function to send the loginfo of the linear and angular velocity.

        Args:
            data (Odometry) - structure consisting of odometry data

        Returns:
            None
        """		
        self.object.position.x = data.pose.pose.position.x 
        self.object.position.y = data.pose.pose.position.y 
        self.object.position.z = data.pose.pose.position.z
        #self.object.orientation = data.pose.pose.orientation        


    def wait_for_state_update(self, box_name, box_is_known=False, box_is_attached=False, timeout=4):
        """ Waits until changes are reflected in object lists 

        Ensures that collision updates are made in case the python node dies before publishing.
        Integrated from Interbotix MoveIt Python Move Group Tutorials

        Args: 
            box_name (string) : name of the box being added 
            box_is_known (bool) : if box is in get_known_object_names()
            box_is_attached (bool) : if box is in get_attached_objects()
            timeout (int) : time limit

        Returns:
            False (bool) : false return if the while loop is exited without returning (a timeout)
        
        """
        start = rospy.get_time()
        seconds = rospy.get_time()

        while (seconds - start < timeout) and not rospy.is_shutdown():
            attached_objects = self.scene.get_attached_objects([box_name])
            is_attached = len(attached_objects.keys()) > 0

            is_known = box_name in self.scene.get_known_object_names()

            if (box_is_attached == is_attached) and (box_is_known == is_known):
                return True

            rospy.sleep(0.1)
            seconds = rospy.get_time()

        return False

    def add_table(self):
        """ Adds worktable to planning scene

        Places table collision object based on the world frame to the left of robot

        """
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = 0.25
        table_pose.pose.position.y = -0.55
        table_pose.pose.position.z = -0.025
        table_pose.pose.orientation.w = 1.0
        table_name = "table"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(1.0, 0.62, 0.05))

    def add_table1(self):
        """ Adds base table to planning scene 

        Places table collision object based on the world frame to front of the robot

        """
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = 0.35
        table_pose.pose.position.y = 0.1
        table_pose.pose.position.z = -0.025
        table_pose.pose.orientation.w = 1.0
        table_name = "table1"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(0.5, 0.62, 0.05))

    def add_object(self):
        """ Adds object to planning scene 
        Places table collision object based on the world frame to front of the robot
        """
        table_pose = PoseStamped()
        table_pose.header.frame_id = "world"
        table_pose.pose.position.x = self.object[0]
        table_pose.pose.position.y = self.object[1]
        table_pose.pose.position.z = self.object[2]
        q1 = transformations.quaternion_about_axis(self.object[5], [0, 0, 1])
        table_pose.pose.orientation = geometry_msgs.msg.Quaternion(*q1)
        table_name = "object"
        while not self.wait_for_state_update(table_name, box_is_known=True):
            self.scene.add_box(table_name, table_pose, size=(0.001, 0.001, 0.05))
    
    def open_gripper(self):
        self.gripper_move_group.set_named_target('open')
        self.gripper_move_group.go()
        self.gripper_move_group.stop()
        self.gripper_move_group.clear_pose_targets()
    
    def close_gripper(self):
        self.gripper_move_group.set_named_target('close')
        self.gripper_move_group.go()
        self.gripper_move_group.stop()
        self.gripper_move_group.clear_pose_targets()

    
    def grasp(self, width, epsilon_inner, epsilon_outer, speed, force):
        """ Uses actions to close gripper 

        Specifies specific width and force with which to grip objects 

        Args: 
            width : width of specified object
            force : force for gripping specified object
        
        """
        self.client.wait_for_server()
        ep = GraspEpsilon(inner = epsilon_inner, outer = epsilon_outer)
        action = GraspGoal()
        action.width = width
        action.epsilon = ep
        action.speed = speed
        action.force = force
        self.client.send_goal(action)
        self.client.wait_for_result(rospy.Duration(15.0))

    def flip_spatula(self):
        """ Moves single joints based on current position 
        
        """
        # two options to get current joint values, current one will save them 
        # joint = self.arm_move_group.get_current_joint_values()
        self.arm_move_group.remember_joint_values("panda_arm")
        joints = self.arm_move_group.get_remembered_joint_values()
        joint = joints["panda_arm"]
        # joint 7 values are between -166 and 166
        logdebug(joint)
        if joint[-1] > 0:
            joint[-1] -= pi
        else:
            joint[-1] += pi
        logdebug(joint)
        self.arm_move_group.set_joint_value_target(joint)
        self.arm_move_group.go()
        self.arm_move_group.stop()
        self.arm_move_group.clear_pose_targets()

    def flip_callback(self, event=None):
        """ Callback function for the flip service 

        Moves the robot to follow waypoints in the parameter server to flip the pancake

        Args: 
            event (Empty) : Event holder for empty input

        Returns:
            EmptyResponse (Empty) : empty response
        
        """
        i = 0
        # if using rpy then euleur to quaternion will give exact movement without offset
        self.open_gripper()

        for waypoint in self.waypoints:
            pose = list_to_pose(waypoint[0])
            gripper = waypoint[1]

            rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 1.0)
            velocity = rospy.get_param("/robot_description_planning/default_velocity_scaling_factor")
            logdebug(velocity)

            self.arm_move_group.set_pose_target(pose)
            success_flag, trajectory_message, planning_time, error_code = self.arm_move_group.plan()
            self.arm_move_group.execute(trajectory_message, wait=True)
            self.arm_move_group.stop()
            self.arm_move_group.clear_pose_targets()

            if gripper:
                self.close_gripper()
                # self.grasp(width=0.05, epsilon_inner=0.001, epsilon_outer=0.001, speed=0.1, force=10)
            else:
                self.open_gripper()

            if i == 2:
                self.flip_spatula()
            i += 1
            rospy.set_param("/robot_description_planning/default_velocity_scaling_factor", 0.1)
            velocity = rospy.get_param("/robot_description_planning/default_velocity_scaling_factor")
            logdebug(velocity)

        return EmptyResponse()


    def tip(self,joint5):
        one, two, three, four, five, six, seven = self.robot_group.get_current_joint_values()
        self.robot_group.set_joint_value_target({'panda_joint1': one, 'panda_joint2': two, 'panda_joint3': three, 'panda_joint4': four, 'panda_joint5': joint5, 'panda_joint6': six, 'panda_joint7': seven})
        self.robot_group.go()
        self.robot_group.stop()

    def spin(self,joint7):

        one, two, three, four, five, six, seven = self.robot_group.get_current_joint_values()
        self.robot_group.set_joint_value_target({'panda_joint1': one, 'panda_joint2': two, 'panda_joint3': three, 'panda_joint4': four, 'panda_joint5': five, 'panda_joint6': six, 'panda_joint7': joint7})
        self.robot_group.go()
        self.robot_group.stop()

    def pour_callback(self,empty):

        self.open_gripper()
        print(self.object)
        '''
        pose = geometry_msgs.msg.Pose()
        pose.position.x = .52304
        pose.position.y = -0.04363
        pose.position.z = .089752
        pose.orientation.x = .58237
        pose.orientation.y = .4014
        pose.orientation.z = -0.40509
        pose.orientation.w = 0.57934
        '''
        goal_vec = [self.object.position.x, self.object.position.y, self.object.position.z]
        self.arm_move_group.set_position_target(goal_vec, end_effector_link=self.eef_link)
        self.arm_move_group.go(wait="true")
        self.arm_move_group.stop()

        # NEED TO KNOW WHERE THE POSITION OF THE END EFFECTOR IS RELATIVE TO THE END OF THE EEF because we should probably back it up some

        print("Grasping")
        self.grasp(.06,.005,.005,.1,20)

        print("Back to home")
        self.go_to_ready()

        print("Tipping")
        joint5 = -np.pi/2
        joint7 = np.pi/2 + np.pi/4
        self.tip(joint5)
        self.spin(joint7)

        print("Squeezing")
        self.grasp(.04,.005,.005,.1,50)

        print("Return bottle")
        self.spin(0)
        '''
        pose = geometry_msgs.msg.Pose()
        pose.position.x = .52304
        pose.position.y = -0.04363
        pose.position.z = .089752
        pose.orientation.x = .58237
        pose.orientation.y = .4014
        pose.orientation.z = -0.40509
        pose.orientation.w = 0.57934
        '''
        self.arm_move_group.go(self.object, wait="true")
        self.arm_move_group.stop()

        self.open_gripper()

        self.go_to_ready()

        return []

    
def main():
    """
    the main() function
    """
    rospy.init_node('manipulator', log_level=rospy.DEBUG)
    node = ManipulatorControl()
    rospy.spin()


if __name__ == '__main__':
    try:
        main()
    except rospy.ROSInterruptException:
        pass