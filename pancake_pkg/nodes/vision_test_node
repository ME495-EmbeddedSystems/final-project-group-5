#!/usr/bin/env python

from numpy.core.defchararray import lower
import rospy
from cv_bridge import CvBridge, CvBridgeError
from sensor_msgs.msg import Image, CompressedImage, CameraInfo
import numpy as np
import cv2
import pyrealsense2 as rs



class ImageProcessing:

    def __init__(self):
        rospy.init_node('vision_test_node',anonymous=True, log_level=rospy.DEBUG)
        rospy.logerr("started the node")

        rospy.Subscriber("/camera/aligned_depth_to_color/image_raw", Image, callback=self.convert_depth_image, queue_size=1)
        rospy.Subscriber("/camera/color/image_raw", Image, callback=self.convert_color_image, queue_size=1)
        rospy.Subscriber("/camera/aligned_depth_to_color/camera_info", CameraInfo, callback=self.get_intrinsics, queue_size=1)
        # rospy.set_param("/pancaked", True)

        self.point_counter = 0
        self.point_matrix = np.zeros((4,2),np.int)

        rospy.logerr('subscribed')

    def show_video(self,name,ros_image):
        cv2.imshow(name,ros_image)
        cv2.waitKey(3)

    def convert_depth_image(self,ros_image):
        bridge = CvBridge()
        # Use cv_bridge() to convert the ROS image to OpenCV format
        try:
            self.depth_image = bridge.imgmsg_to_cv2(ros_image)
            depth_array = np.array(self.depth_image, dtype=np.float32)
            #self.show_video(depth_image)

        except CvBridgeError:
            print(CvBridgeError())
            rospy.logerr("bad")

    def convert_color_image(self,ros_image):
        bridge = CvBridge()
        try:
            self.bgr_image = bridge.imgmsg_to_cv2(ros_image)
            self.hsv_image = cv2.cvtColor(self.bgr_image, cv2.COLOR_BGR2HSV)
            self.rgb_image = cv2.cvtColor(self.bgr_image, cv2.COLOR_BGR2RGB)
            self.grayscale_image = cv2.cvtColor(self.bgr_image, cv2.COLOR_BGR2GRAY)

            # while self.point_counter < 4:
                
            #     for x in range(4):
            #         cv2.circle(self.grayscale_image,(self.point_matrix[x][0],self.point_matrix[x][1]),3,(0,255,0),cv2.FILLED)
                
            #     # Showing original image
            #     cv2.imshow("Original Image ",self.grayscale_image)
            #     # Mouse click event on original image
            #     cv2.setMouseCallback("Original Image ", self.mouse_coords)
            #     # Printing updated point matrix
            #     print(self.point_matrix)
            #     # Refreshing window all time
            #     cv2.waitKey(1)               

            self.find_bottle_location()

            
            self.pancake_flag = rospy.get_param("/pancaked")
            if self.pancake_flag:
                self.find_pancake_location()
            # except:
            #     pass

            self.show_video("test",self.rgb_image)

        except CvBridgeError:
            print(CvBridgeError())
            rospy.logerr("bad")

    # def mouse_coords(self,event,x,y,flags,params):
    #     # Left button mouse click event opencv
    #     if event == cv2.EVENT_LBUTTONDOWN:
    #         self.point_matrix[counter] = x,y
            # self.point_counter += 1

    def get_intrinsics(self, camera_info):
        self.intr = rs.intrinsics()
        self.intr.width = camera_info.width
        self.intr.height = camera_info.height
        self.intr.ppx = camera_info.K[2]
        self.intr.ppy = camera_info.K[5]
        self.intr.fx = camera_info.K[0]
        self.intr.fy = camera_info.K[4]
        self.intr.model = rs.distortion.none
        self.intr.coeffs = [0.0, 0.0, 0.0, 0.0, 0.0]

    def find_bottle_location(self):            

            red_low = np.array([80,10,10])
            red_up = np.array([255,255,255])

            self.redmask = cv2.inRange(self.hsv_image,red_low,red_up)

            self.masked_image = cv2.bitwise_and(self.hsv_image,self.hsv_image,mask=self.redmask)

            self.masked_image_gray = cv2.cvtColor(self.masked_image, cv2.COLOR_RGB2GRAY)
            
            ret, thresh = cv2.threshold(self.masked_image_gray, 130,255, cv2.THRESH_BINARY)

            contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)

            areas = [cv2.contourArea(c) for c in contours]
            max_index = np.argmax(areas)
            cnt=contours[max_index]

            x,y,w,h = cv2.boundingRect(cnt)
            cv2.rectangle(self.rgb_image,(x,y),(x+w,y+h),(0,255,0),2)

            M = cv2.moments(cnt)
            self.cx = int(M['m10']/M['m00'])
            self.cy = int(M['m01']/M['m00'])

            cv2.circle(self.rgb_image, (self.cx,self.cy), 4, (255,0,0), 3)

            result = self.get_xyz_from_image(self.depth_image, self.cx, self.cy)

    def find_pancake_location(self):
        print("finding pancake?")
        self.pancake_pos = rospy.get_param("/saved_pancake_pose")
        # self.pancake_pos = self.get_xyz_from_image(self.depth_image, self.cx, self.cy)

        self.pancake_pos_pixel = rs.rs2_project_point_to_pixel(self.intr, self.pancake_pos)
        
        black_mask = np.zeros((720, 1280), np.uint8)

        cv2.circle(black_mask, (int(self.pancake_pos_pixel[0]), int(self.pancake_pos_pixel[1])), 80,255, -1)

        self.rgb_image = cv2.circle(self.rgb_image, (int(self.pancake_pos_pixel[0]), int(self.pancake_pos_pixel[1])), 80, (255,0,0), 3)

        masked_img = cv2.bitwise_and(black_mask, self.grayscale_image)

        canny_pancake = cv2.Canny(masked_img,50,150, 5, L2gradient = True)

        contours, heir = cv2.findContours(canny_pancake, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        num_contours = len(contours)

        if num_contours > 40:
            rospy.set_param("/flip_time", True)






    def get_xyz_from_image(self,depth_image, x,y):
        result = rs.rs2_deproject_pixel_to_point(self.intr, [x,y], depth_image[y,x])
        return result 

if __name__ == '__main__':
    ImageProcessing()
    rospy.spin()